"""
Scan Client Tools

Helpers for connecting to the Scan Server,
to assemble commands for a scan,
submit them to the server,
monitor the execution.

Shortcuts for 1D, 2D, *D scans.

This code depends on the basic org.csstudio.scan.* packages.
It can be invoked from Jython scripts associated with BOY displays
but also from jython command lines outside of CSS.

@author: Kay Kasemir
"""
import sys
import os
import glob

# -------------------------------------------------------
# Path setup
#
# 1)  When running under Eclipse (from BOY displays),
#     this code locates the scan plugins.
#     Nothing else to do; variables set below are replaced
#     by the actual plugin location.
#
# 2a) When running outside of Eclipse
#     (jython command-line, Matlab, also scripts executed from PyDev)
#     either set the path to the standalone scan.client.jar
#     (generated by org.csstudio.scan.client/build.xml)
scan_client_jar="/usr/local/css/scan.client.jar"

# 2b) ... or give the path to the plugin directory
#     (which is automatically determined for case 1)
plugin_install_location="/usr/local/css/CSS_3.2/plugins/"

# Try to resolve the paths when running outside of Eclipse
try:
    scan_plugin = glob.glob(plugin_install_location + "org.csstudio.scan_*")[0]
    client_plugin = glob.glob(plugin_install_location + "org.csstudio.scan.client_*")[0]
except:
    pass # Ignore. May use scan_client_jar or be running under Eclipse

# When running under Eclipse, replace settings with info from registry
def __getPluginPath__(plugin):
    """ Get path to classes in plugin (if running under Eclipse)
        @param plugin Plugin ID
        @return Path to the classes in the plugin, or None
    """
    try:
        # Under Eclipse, should be able to locate the bundle
        from org.eclipse.core.runtime import Platform
        from org.eclipse.core.runtime import FileLocator
        from org.eclipse.core.runtime import Path
        bundle = Platform.getBundle(plugin)
        # While in the IDE, the classes are in a bin subdir
        url = FileLocator.find(bundle, Path("bin"), None)
        if url:
            return FileLocator.resolve(url).getPath()
        # In an exported product, the classes are
        # at the root of the jar or the expanded
        # plugin directory
        return FileLocator.getBundleFile(bundle).getPath()
    except:
        # Not running under Eclipse
        return None

path = __getPluginPath__("org.csstudio.scan")
if path:
    scan_plugin = path
path = __getPluginPath__("org.csstudio.scan.client")
if path:
    client_plugin = path

# Now one of the possibilities should work out...
if os.path.exists(scan_plugin) and os.path.exists(client_plugin):
    sys.path.append(scan_plugin)
    sys.path.append(client_plugin)
elif os.path.exists(scan_client_jar):
    sys.path.append(scan_client_jar)
else:
    raise Exception("Scan client library not configured")
    
#from org.eclipse.jface.dialogs import MessageDialog
#for p in sys.path:
#    MessageDialog.openWarning(None, "Debug", "Using " + p)

# -------------------------------------------------------
# Scan Server connection setup

import org.csstudio.scan.server.ScanServer as ScanServer
import java.lang.System as System
    
# Set scan server host and port if they're not the default.
# Can also pass this as command-line definitions to jython:
#  jython  -DScanServerHost=ky9linux.ornl.gov ....
#System.setProperty(ScanServer.HOST_PROPERTY, "ky9linux.ornl.gov")
#System.setProperty(ScanServer.PORT_PROPERTY, str(4810))


# -------------------------------------------------------
# Leave rest as is

# Python packages are different from Java Packages
# There can be issues with 'package scanning' that cause
# jython to not find classes when using
#   from org.csstudio.scan.command import *
# or
#   import org.csstudio.scan.command
#
# The most dependable way is to explicitly import one-by-one
import org.csstudio.scan.client.ScanServerConnector as ScanServerConnector
import org.csstudio.scan.command.CommandSequence as CommandSequence
import org.csstudio.scan.command.LoopCommand as LoopCommand
import org.csstudio.scan.command.Comparison as Comparison
import org.csstudio.scan.command.ScanCommand as ScanCommand
import org.csstudio.scan.command.WaitCommand as WaitCommand
import org.csstudio.scan.command.DelayCommand as DelayCommand
import org.csstudio.scan.command.LogCommand as LogCommand
import org.csstudio.scan.command.SetCommand as SetCommand

import time


class ScanClient(object):
    """
    Base class for a scan client
    
    Can submit scans to the server and monitor them
    """
    def __init__(self):
        # Connection to the scan server
        self.server = ScanServerConnector.connect()
        # Scan ID
        self.id = -1
        
    def checkServer(self):
        """
        Attempt to call the server, and try to re-connect on error.
        
        The server could be restarted, or there could have been
        a network issue between the time we originally connected
        to the server and now, which would invalidate the original
        server connection.
        """
        try:
            self.server.getInfo()
        except:
            self.server = ScanServerConnector.connect()

    def submit(self, name, command_sequence):
        """
        Submit a CommandSequence to the server for execution
        
        @param name  Name of the scan
        @param command_sequence  CommandSequence
          
        @return Scan ID
        """
        self.checkServer()
        self.id = self.server.submitScan(name, command_sequence.getXML())
        return self.id

    def getScanInfo(self, id=-1):
        """
        Get scan info
        
        @param id Scan ID, defaulting to the last submitted scan
        """
        self.checkServer()
        if id == -1:
            id = self.id
        return self.server.getScanInfo(id)

    def waitUntilDone(self, id=-1):
        """
        Wait until a submitted scan has finished
        
        @param id Scan ID, defaulting to the last submitted scan
        """
        while True:
            info = self.getScanInfo(id)
            print info
            if info.getState().isDone():
                break;
            time.sleep(1.0)
            
    def __str__(self):
        return "Scan client, connected to %s" % self.server.getInfo()



class ScanNd(ScanClient):
    """
    N-dimensional scan that logs arbitrary number of readings
    based on nested loops.
    
    Arguments:
    
    * Optional scan name
    * One or more scan specifications: ('device', start, end[, step])
    * Names of device to log in addition to loop'ed devices
    * Commands to perform in innermost loop
    
    Examples:
    
    # Scan 'xpos' from 1 to 10, stepping 1
    scan('My first one', ('xpos', 1, 10) )
    # Scan name is optional
    scan( ('xpos', 1, 10) )

    # Log the 'readback' (xpos is logged automatically)
    scan( ('xpos', 1, 10), 'readback')
    
    # Scan 'xpos' from 1 to 10, stepping 1,
    # inside that looping 'ypos' from 1 to 5 by 0.2,
    # logging 'readback'
    scan('XY Example', ('xpos', 1, 10), ('ypos', 1, 5, 0.2), 'readback')

    # Scan 'xpos' and 'ypos', set something to '1' and then '3' (with readback)
    scan('XY Example', ('xpos', 1, 10), ('ypos', 1, 5, 0.2),
         SetCommand('setpoint', 1, 'readback'),
         SetCommand('setpoint', 3, 'readback'))
    """
    
    def __init__(self):
        ScanClient.__init__(self)

    def _decodeScan(self, parms):
        """ Check for 
                ('device', start, end, step)
             or 
                ('device', start, end)
             for a default step size of 1
        """
        if (len(parms) == 4):
            return (parms[0], parms[1], parms[2], parms[3])
        elif (len(parms) == 3):
            return (parms[0], parms[1], parms[2], 1)
        else:
            raise Exception('Scan parameters should be (''device'', start, end, step), not %s' % str(parms)) 
    
    def __call__(self, *args):
        """ N-dimensional scan command.
            @return ID of scan that was scheduled on the scan server
        """
        args = list(args)
        if len(args) > 0  and  isinstance(args[0], str):
            name = args[0]
            args.pop(0)
        else:
            name = "Scan"
        
        # Prepare body of innermost loop
        body = CommandSequence()
        # Determine the (nested) scans, inner loop commands and devices to log
        # (doesn't really care if inner commands and log devices are listed last)
        scans = []
        log = []
        for arg in args:
            if isinstance(arg, tuple):
                scan = self._decodeScan(arg)
                scans.append(scan)
            elif isinstance(arg, ScanCommand):
                body.add(arg)
            else:
                log.append(arg)
        
        # Innermost loop's log command
        if len(log) > 0:
            body.log(log)

        # Wrap by scans, going in reverse from inner loop
        scans.reverse()
        cmds = CommandSequence()
        for scan in scans:
            # Add cmds from inner loop (nothing on first iteration)
            body.add(cmds)
            
            # Wrap in loop which then becomes cmds to next loop 'up'
            cmds = CommandSequence()
            cmds.loop(scan[0], scan[1], scan[2], scan[3], body)
            
            # Prepare empty body for next loop
            body = CommandSequence()
            
        id = self.submit(name, cmds)
        if __name__ == '__main__':
            cmds.dump()
            self.waitUntilDone()
        return id

# Create 'scan' command
scan = ScanNd()

if __name__ == '__main__':
    print 'Welcome to the scan system'
    # print 'Running in %s' % os.getcwd()
    print 'Connected to %s' % scan.server.getInfo()
    
    # 'Normal' loops
    #scan('Normal 2D', ('xpos', 1, 10), ('ypos', 1, 10, 0.5), 'readback')

    # 'Reversing' inner loop
    #scan('Reversing 2D', ('xpos', 1, 10), ('ypos', 1, 10, -0.5), 'readback')

