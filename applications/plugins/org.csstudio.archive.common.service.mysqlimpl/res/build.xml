<project name="DatabaseCreation" basedir=".">
    <property name="sql.driver" value="com.mysql.jdbc.Driver"/>
    <property name="sql.connector.classpath" value="../../com.mysql.jdbc"/>
	
	<!-- 
        Import the environment as properties prefixed with 'env'. 
        Then set env.HOSTNAME to be the value of env.COMPUTERNAME (in case of windows OS) 
        unless env.HOSTNAME (in case of linux OS) is already set in which case the 2nd line will 
        have no effect (ant props are immutable). After that use env.HOSTNAME where the hostname 
        is required.
    -->
	<target name="prepare.env">
        <property environment="env"/>
		
		<!-- 
		     sets host.name to the first env variable for the HOST/HOSTNAME/COMPUTERNAME that can be 
		     found, once set the property host.name is immutable, remaining conditions don't have 
		     any effect.
		 -->
		<condition property="host.name.org" value="${env.HOST}">
		    <isset property="env.HOST"/> <!-- Solaris -->
		</condition>

		<condition property="host.name.org" value="${env.HOSTNAME}">
		    <isset property="env.HOSTNAME"/> <!-- Linux -->
		</condition>

		<condition property="host.name.org" value="${env.COMPUTERNAME}">
		    <isset property="env.COMPUTERNAME"/> <!-- Windows -->
		</condition>

        <echo message="HOSTNAME ORG = ${host.name.org}"/>
		<script language="javascript"><![CDATA[
			orgProp = DatabaseCreation.getProperty("host.name.org");
			DatabaseCreation.setProperty("host.name", orgProp.toLowerCase());
		]]></script>
        <echo message="HOSTNAME to lowercase = ${host.name}"/>
		
		<!-- 
		    Process host.properties file 
		    Filter for props for being prefixed with host.name (case-insensitive)
		    Remove all prefixes, load the props
		 -->
        <loadproperties srcfile="../../../../../config/DESY/host.properties">
            <filterchain>
            	<tokenfilter>
            	    <containsregex pattern="^${host.name}\.(.+)$" flags="i"
            	                   replace="\1"/>
            	</tokenfilter>
            </filterchain>
        </loadproperties>
		<!-- 
		    Process host.properties file again
		    Filter for props for being prefixed with "root." (case-insensitive)
		    Remove all prefixes, load the props (those being loaded before cannot be overridden - props are immutable)
		 -->
        <loadproperties srcfile="../../../../../config/DESY/host.properties">
            <filterchain>
            	<tokenfilter>
            	    <containsregex pattern="^root\.(.+)$" flags="i"
            	                   replace="\1"/>
            	</tokenfilter>
            </filterchain>
        </loadproperties>
		<echo message="Properties with prefix '${host.name}.' and 'root.' loaded!"/>
	    
	    <property name="sql.host" value="${mysqlHost}"/>
	    <property name="sql.url" value="jdbc:mysql://${sql.host}:${mysqlPort}"/>
	    <property name="sql.root.user" value="${mysqlRootUser}"/>
	    <property name="sql.root.pw" value="${mysqlRootPassword}"/>
		
	    <property name="sql.archive.db" value="${mysqlArchiveDatabase}"/>
	    <property name="sql.archive.user" value="${mysqlArchiveUser}"/>
	    <property name="sql.archive.pw" value="${mysqlArchivePassword}"/>

		<echo message="sql.url : ${sql.url}"/>
		<echo message="sql.root.user : ${sql.root.user}"/>
		<echo message="sql.root.pw : ${sql.root.pw}"/>
		<echo message="sql.root.url : ${sql.root.pw}"/>
		<echo message="sql.archive.db : ${sql.archive.db}"/>
		<echo message="sql.archive.user : ${sql.archive.user}"/>
		<echo message="sql.archive.pw : ${sql.archive.pw}"/>
		
	</target>
	


    <target name="create.and.fill.database" 
    	    depends="create.database, create.tables, create.triggers">
    </target>
	
   <target name="create.database" depends="drop.database">
      <sql driver="${sql.driver}" 
           url="${sql.url}" 
           userid="${sql.archive.user}" 
           password="${sql.archive.pw}">
      	<classpath>
      	    <pathelement path="${sql.connector.classpath}"/>
      	</classpath>
      	
      	<transaction>
      	    CREATE DATABASE ${sql.archive.db};
      	    USE ${sql.archive.db};
      	</transaction>
      </sql>
   </target>
   
    <target name="create.tables" depends="prepare.env">
        <sql driver="${sql.driver}" 
             url="${sql.url}/${sql.archive.db}" 
             userid="${sql.archive.user}" 
             password="${sql.archive.pw}">
            <classpath>
                <pathelement path="${sql.connector.classpath}"/>
            </classpath>     	
        
         	<!-- Take care, order matters due to foreign key constraints -->
            <transaction src="tables/engine.sql"/>
            <transaction src="tables/engine_status.sql"/>
            <transaction src="tables/channel_group.sql"/>
            <transaction src="tables/control_system.sql"/>
            <transaction src="tables/channel.sql"/>
            <transaction src="tables/channel_status.sql"/>
            <transaction src="tables/sample.sql"/>
            <transaction src="tables/sample_m.sql"/>
            <transaction src="tables/sample_h.sql"/>
        </sql>
    </target>

    <target name="create.triggers" depends="prepare.env">
        <sql driver="${sql.driver}" 
             url="${sql.url}/${sql.archive.db}" 
             userid="${sql.archive.user}" 
             password="${sql.archive.pw}"
      	     delimiter="//">
            <classpath>
                <pathelement path="${sql.connector.classpath}"/>
            </classpath>
      	
            <transaction src="tables/triggers.sql"/>
       </sql>
    </target>
	
    <target name="drop.database" depends="prepare.env">
	    <input message="Do you really want to delete database '${sql.archive.db}'?" 
               validargs="y,n" 
	           addproperty="do.delete"
               defaultvalue="y" />
        <condition property="do.abort"> 
            <equals arg1="n" arg2="${do.delete}"/> 
        </condition> 
        <fail if="do.abort">Build aborted by user.</fail> 
        
        <sql driver="${sql.driver}" 
             url="${sql.url}" 
             userid="${sql.archive.user}" 
        	 password="${sql.archive.pw}">
             <classpath>
                 <pathelement path="${sql.connector.classpath}"/>
             </classpath>
            
             <transaction>
                 DROP DATABASE IF EXISTS ${sql.archive.db};
             </transaction>
         </sql>
    </target>
	
	<target name="clear.tables" depends="prepare.env">
        <sql driver="${sql.driver}" 
             url="${sql.url}/${sql.archive.db}" 
             userid="${sql.archive.user}" 
        	 password="${sql.archive.pw}">
             <classpath>
                 <pathelement path="${sql.connector.classpath}"/>
             </classpath>
            
             <!-- 
                 Order matters - it's vice versa as the table creation due to foreign key constraints
                 And deletion instead of truncation is used on tables where foreign keys point to.  
              -->
             <transaction>
             	TRUNCATE TABLE sample_h;
             	TRUNCATE TABLE sample_m;
             	TRUNCATE TABLE sample;
             	TRUNCATE TABLE channel;
             	TRUNCATE TABLE channel_status; 
             	DELETE FROM control_system;
             	DELETE FROM channel_group;
             	TRUNCATE TABLE engine_status;
             	DELETE FROM engine;
             </transaction>
         </sql>
	</target>
	
	<target name="run.on.mysqlhost.after.installation" 
		    description="Run this target on your mysql host: connect as root, set root password \
		                 according to host.properties, create archive user, create archive db, \
		                 grant privileges"
		    depends="prepare.env">
		
        <sql driver="${sql.driver}" 
             url="jdbc:mysql://localhost:${mysqlPort}" 
             userid="${sql.root.user}"
        	 password="">
             <classpath>
                 <pathelement path="${sql.connector.classpath}"/>
             </classpath>
            
             <!-- 
                 Order matters - it's vice versa as the table creation due to foreign key constraints
                 And deletion instead of truncation is used on tables where foreign keys point to.  
              -->
             <transaction>
             	SET PASSWORD=PASSWORD('${sql.root.pw}');
             	DROP USER '${sql.root.user}'@'%';
             	CREATE USER '${sql.root.user}'@'%' identified by '${sql.root.pw}' IDENTIFIED BY '${sql.root.pw}';
             	GRANT ALL PRIVILEGES ON *.* to '${sql.root.user}'@'%' WITH GRANT OPTION;
             	
             	DROP USER '${sql.archive.user}'@'localhost';
             	CREATE USER '${sql.archive.user}'@'localhost' identified by '${sql.archive.pw}';
             	DROP USER '${sql.archive.user}'@'${sql.host}';
             	CREATE USER '${sql.archive.user}'@'${sql.host}' identified by '${sql.archive.pw}';
             	DROP USER '${sql.archive.user}'@'%';
             	CREATE USER '${sql.archive.user}'@'%' identified by '${sql.archive.pw}';
             	
             	GRANT ALL PRIVILEGES ON ${sql.archive.db}.* to '${sql.archive.user}'@'localhost';
             	GRANT ALL PRIVILEGES ON ${sql.archive.db}.* to '${sql.archive.user}'@'${sql.host}';
             	GRANT ALL PRIVILEGES ON ${sql.archive.db}.* to '${sql.archive.user}'@'%';
             	FLUSH PRIVILEGES;
             </transaction>
         </sql>
		
	</target>
</project>
