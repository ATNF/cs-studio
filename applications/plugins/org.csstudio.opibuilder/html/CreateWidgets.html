<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=Cp1252"/>
    <link rel="stylesheet" href="default.css" type="text/css" />
    <title>
      Creating Widgets for BOY
    </title>
</head>
<body>

<h2>Creating Custom BOY Widgets</h2>
<h3>1. Introduction</h3>
<p>
BOY is able to load custom widgets using Eclipse Plugin mechanism, so user can implements their own widgets by 
creating a new Eclipse plugin without touching BOY code. If you do think your widget can benefit other people,
you can send your widget code to <a href="mailto:chenx1@ornl.gov">chenx1@ornl.gov</a> so we can integrate it into BOY as a native BOY widget.
This chapter will give you the concept of BOY widget and a step-by-step example. Before start, you should have 
some basic knowledge in Java and Eclipse plugin. The BOY widget figure is drawn by Draw2d, so you may also need
to learn the basics of <a href = http://help.eclipse.org/galileo/index.jsp?topic=/org.eclipse.draw2d.doc.isv/guide/guide.html>Draw2d</a>.     
</p>

<h3>2. Concepts</h3>
<p>All BOY widgets should rely on the MVC (Model-View-Controller) pattern to separate 
responsibilities among their single components.
<ul>
	<li><b>Model</b>
	<p>The model of a widget defines the set of properties, stores the according values. 
	The model contains all data that gets persisted.</p></li>
	<li><b>View</b>
	<p>The view is a figure which is visible to the user.</p></li>
	<li><b>Controller</b>
	<p>The controller is called <code>Editpart</code>. Editparts are the link between the model and the view. 
	It is responsible for the behavior of the widget when properties value changed.</p>
	</li>
</ul>
<p>

<h3>3. A Step-by-Step Example</h3>
<p>This example will create a simple bar graph widget which can display a numeric 
PV value.</p>

<h4>3.1 Pre-requirements</h4>
<p>The widget plugin will need to have BOY plugin (org.csstudio.opibuilder) as dependecy, 
so you need to have BOY plugin and its dependent CSS plugins installed in your 
Eclipse environment. You can simply copy BOY plugin and its dependencies from
your CSS plugin folder to your Eclipse plugin folder. If you are a CSS developer, you just need to
import these plugins into your workspace from your Mercurial repository.</p>

<h4>3.2 Creating a new plugin</h4>
<p>Create a new plugin project with all the default settings. Add plugin org.csstudio.opibuilder as dependency.</p>

<h4>3.3 Creating the widget model</h4>
<p>The class <code>org.csstudio.opibuilder.model.AbstractWidgetModel</code> is the base class of all BOY widget
models. All the common widget properties are defined in <code>AbstractWidgetModel</code>:
<ul>
<li>Name</li>
<li>X, Y, Width, Height</li>
<li>Foreground Color, Backgournd Color</li>
<li>Enable, Visible</li>
<li>Border Style, Border Color, Border Width</li>
<li>Scripts, Rules and Actions</li>
</ul>
<p><code>AbstractWidgetModel</code> defines two abstract methods you have to implement 
within your custom model.The <code>getTypeID()</code> method should return a unique ID 
which is used by the BOY framework to identify your model class.
The <code>configureProperties()</code> method is called by the BOY framework 
during the instantiation of your model class. You can use it to equip your own widget model 
with custom properties. To do so, you need to call <code>addProperty(..)</code> to add 
a new property to the model’s property set. The signature of the addProperty(..) method
 requests a property ID that must be unique within the widget model and an instance of 
 <code>org.csstudio.opibuilder.properties.AbstractWidgetProperty</code> that defines the property type.
The supported property types are described at <a href = "script/PropertyType.html">here</a>. 
You can also create your own property type by extending 
<code>org.csstudio.opibuilder.properties.AbstractWidgetProperty</code>.

<p>
The <code>class org.csstudio.opibuilder.model.AbstractPVWidgetModel</code> is the base class of all widgets that have the 
capability of connecting PVs. It provides additional common widget properties:
<ul>
<li>PV Name</li>
<li>PV Value (This property is an inner property which will not be shown in property sheet).</li>
<li>BackColor Alarm Sensitive</li>
<li>ForeColor Alarm Sensitive</li>
<li>Border Alarm Sensitive</li>
</ul> 

<p>Our simple bar graph widget will need to connect PV, so it needs to subclass <code>AbstractPVWidgetModel</code>.
We will add two double properties to this widget: <code>Min</code> and <code>Max</code>.
</p>
<pre class = "example_code">
public class SimpleBarGraphModel extends AbstractPVWidgetModel{

	/** Lower limit of the widget. */
	public static final String PROP_MIN = "max"; //$NON-NLS-1$		
	
	/** Higher limit of the widget. */
	public static final String PROP_MAX = "min"; //$NON-NLS-1$		
	
	public final String ID = "org.csstudio.opibuilder.widgetExample.SimpleBarGraph"; //$NON-NLS-1$
	
	/**
	 * Initialize the properties when the widget is first created.
	 */
	public SimpleBarGraphModel() {
		setForegroundColor(new RGB(255, 0, 0));
		setBackgroundColor(new RGB(0,0,255));
		setSize(50, 100);
	}
	
	@Override
	protected void configureProperties() {
		addProperty(new DoubleProperty(PROP_MIN, "Min", WidgetPropertyCategory.Behavior, 0));
		addProperty(new DoubleProperty(PROP_MAX, "Max", WidgetPropertyCategory.Behavior, 100));
	}

	@Override
	public String getTypeID() {
		return ID;
	}
	
	/**
	 * @return the lower limit
	 */
	public double getMin(){
		return getCastedPropertyValue(PROP_MIN);
	}
	
	/**
	 * @return the higher limit
	 */
	public double getMax(){
		return getCastedPropertyValue(PROP_MAX);
	}
}
</pre>

<h4>3.4 Creating the view</h4>
<p>The view is responsible for the graphical representation of the widget. 
All widget view must implement the interface
of <code>org.eclipse.draw2d.IFigure</code>. The class <code>org.eclipse.draw2d.Figure</code> 
has implemented most of the functions, most of BOY widgets figure extended this class.In most cases,
the widget figure should be drawn in the function of <code>paintClientArea()</code>. The client area is the 
area that is inside the border. So paint in this area will not affect the border area. BOY will automatically 
draw borders for all widgets based on the border setting, so you do not need to consider the border in most cases.</p>
<pre class="example_code">
public class SimpleBarGraphFigure extends Figure {	
	
	private double min =0;
	private double max = 100;
	private double value = 50;
	
	@Override
	protected void paintClientArea(Graphics graphics) {
		super.paintClientArea(graphics);
		//fill background rectangle
		graphics.setBackgroundColor(getBackgroundColor());
		graphics.fillRectangle(getClientArea());
		
		//fill foreground rectangle which show the value's position
		graphics.setBackgroundColor(getForegroundColor());
		//coerce drawing value in range
		double coercedValue = value;
		if(value < min)
			coercedValue = min;
		else if (value > max)
			coercedValue = max;
		int valueLength = (int) ((coercedValue-min)*getClientArea().height/(max-min));
		graphics.fillRectangle(getClientArea().x, 
				getClientArea().y + getClientArea().height -valueLength, 
				getClientArea().width, valueLength);		
	}
	
	public void setMin(double min) {
		this.min = min;
		repaint();
	}
	
	public void setMax(double max) {
		this.max = max;
		repaint();
	}
	
	public void setValue(double value) {
		this.value = value;
		repaint();
	}
	
	public double getValue() {
		return value;
	}	
}</pre>

<h4>3.5 Creating the controller (editpart)</h4>

<p>BOY widget controller basically are special GEF edit parts. You don't need in-depth
knowledge about GEF for most regular widgets. BOY provides a comfortable framework for that. 
If you want to have special behaviors on your widgets, for example, changing the behavior when you
are clicking or draging the widget, you may need to have further knowledge about GEF. </p> 

<p>All BOY widget controllers must subclass 
<code>org.csstudio.opibuilder.editparts.AbstractWidgetEditPart</code>. For widget that needs to 
connect to PV, its controller need to subclass
 <code>org.csstudio.opibuilder.editparts.AbstractPVWidgetEditPart</code>. </p>

<pre class = "example_code">
public class SimpleBarGraphEditpart extends AbstractPVWidgetEditPart {

	/**
	 * Create and initialize figure.
	 */
	@Override
	protected IFigure doCreateFigure() {
		SimpleBarGraphFigure figure = new SimpleBarGraphFigure();
		figure.setMin(getWidgetModel().getMin());
		figure.setMax(getWidgetModel().getMax());
		return figure;
	}
	
	/**Get the widget model.
	 * It is recommended that all widget controller should override this method.
	 *@return the widget model.
	 */
	@Override
	public SimpleBarGraphModel getWidgetModel() {
		return (SimpleBarGraphModel) super.getWidgetModel();
	}

	@Override
	protected void registerPropertyChangeHandlers() {
		// The handler when PV value changed.
		IWidgetPropertyChangeHandler valueHandler = new IWidgetPropertyChangeHandler() {
			public boolean handleChange(final Object oldValue,
					final Object newValue,
					final IFigure figure) {
				if(newValue == null)
					return false;
				 ((SimpleBarGraphFigure) figure).setValue(ValueUtil.getDouble((IValue)newValue));
				return false;
			}
		};
		setPropertyChangeHandler(AbstractPVWidgetModel.PROP_PVVALUE, valueHandler);
		
		//The handler when max property value changed.
		IWidgetPropertyChangeHandler maxHandler = new IWidgetPropertyChangeHandler() {
			
			public boolean handleChange(Object oldValue, Object newValue, IFigure figure) {
				((SimpleBarGraphFigure) figure).setMax((Double)newValue);
				return false;
			}
		};
		setPropertyChangeHandler(SimpleBarGraphModel.PROP_MAX, maxHandler);
		
		//The handler when min property value changed.
		IWidgetPropertyChangeHandler minHandler = new IWidgetPropertyChangeHandler() {
			
			public boolean handleChange(Object oldValue, Object newValue, IFigure figure) {
				((SimpleBarGraphFigure) figure).setMin((Double)newValue);
				return false;
			}
		};
		setPropertyChangeHandler(SimpleBarGraphModel.PROP_MIN, minHandler);
		
	}
	
	@Override
	public Object getValue() {
		return ((SimpleBarGraphFigure)getFigure()).getValue();
	}

	@Override
	public void setValue(Object value) {
		if(value instanceof Double)
			((SimpleBarGraphFigure)getFigure()).setValue((Double)value);
	}
}
</pre>

<p>The <code>doCreateFigure()</code> method creates figure by instantiating a SimpleBarGraphFigure.
It is also reponsible for initializing the figure with the property value in model. 
The <code>registerPropertyChangeHandlers()</code> method is responsible for the behavior of the widget
when its property value changed. A property can have more than one handler. All handlers must implement
the interface of <code>IWidgetPropertyChangeHandler</code>. The <code>handleChange()</code>method will handle
the property value change in which <code>oldValue</code> is the old property value, <code>newValue</code> is the 
new property value, <code>figure</code> is the widget figure.
</p>

<h4>3.6 Register the widget with BOY</h4>
<p>So far, we have finished the coding part. Now, we need to register this widget with BOY so that BOY can 
recognize and list this widget in its widget palette.</p>
<p>Open the <code>MANIFEST.MF</code> file in your plugin project. Go to the tab of <code>extensions</code>.
Add an extension <code>org.csstudio.opibuilder.widget</code>. Configure the extension properties as shown in 
the figure. </p><p>
<img alt="BOY Widget Extension" src="img/WidgetExtension.PNG">

<ul>
<li>typeId<p>The global unique typeId of the widget which is the return value of the method <code>getTypeID()</code> 
in widget model. </p></li>
<li>name <p>The name of the widget, which will appear in the widget palette.</p></li>
<li>category<p>The category of the widget. The default categories include 
<b>Graphics</b>, <b>Monitors</b>, <b>Controls</b> and <b>Others</b>. You can create a new category by giving a new 
category name, but this is not recommended.</p></li>
<li>icon<p>The icon of the widget.</p></li>
<li>model_class<p>The model of the widget.</p></li>
<li>editpart_class<p>The editpart class of the widget.</p></li>
<li>description<p>The description of the widget, which will be displayed as the tooltip.</p></li>
</ul>

<h4>3.7 Integrate the widget into CSS</h4>
<p>If you are a CSS developer, now your have finished the plugin project. 
You can integrate it into CSS by including this plugin into your CSS build.</p>
<p>Here we will discuss how to add this widget to an existing CSS.</p>
<p>Open the <code>MANIFEST.MF</code> file and go to the <code>overview</code> tab. 
Click <code>Export Wizard</code>. Change the Destination Directory to the any directory you want. Leave other
settings as default and click <code>Finish</code>. When exporting finished, go to the directory you set and copy
the jar file in <code>plugin</code> folder to the CSS <code>dropins</code> folder. Start CSS, you will see the
Simple Bar Graph widget in you CSS BOY palette! You can test it by setting
 <code>PV Name</code> to <code>sim://noise</code>, setting <code>max</code> to 5, <code>min</code> to -5. You will
 see it already has all the BOY PV widget functions such as PV connection, Border alarm sensitive and so on.</p>
<p>
<img alt="Simple Bar Graph widget" src="img/SimpleBarGraph.PNG">
</p>

<p>*This project zip file can be found at BOY Examples->Miscellaneous->CustomizedWidgetExample.zip. You can import it into your Eclipse
 workspace by selecting <code>File->Import...->Existing Project into workspace</code>.</p>
</body>
</html>
