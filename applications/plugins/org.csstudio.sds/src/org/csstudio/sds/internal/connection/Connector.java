package org.csstudio.sds.internal.connection;

import java.util.ArrayList;
import java.util.List;

import org.csstudio.platform.logging.CentralLogger;
import org.csstudio.platform.model.pvs.IProcessVariableAddress;
import org.csstudio.sds.model.DynamicsDescriptor;
import org.csstudio.sds.model.WidgetProperty;
import org.csstudio.sds.model.properties.IPropertyChangeListener;
import org.csstudio.sds.model.properties.PropertyTypesEnum;
import org.epics.css.dal.DynamicValueCondition;
import org.epics.css.dal.DynamicValueEvent;
import org.epics.css.dal.DynamicValueListener;
import org.epics.css.dal.DynamicValueProperty;
import org.epics.css.dal.DynamicValueState;
import org.epics.css.dal.ResponseEvent;
import org.epics.css.dal.ResponseListener;
import org.epics.css.dal.context.ConnectionEvent;
import org.epics.css.dal.context.ConnectionState;
import org.epics.css.dal.context.LinkListener;

/**
 * 
 * Base class for connectors that manage input channels. Input channels are
 * channels that deliver values during runtime.
 * 
 * In comparison to the {@link WriteConnector} the control flow is inverted. In
 * this case a value must be transported FROM the specific channel architecture
 * TO the application frontend.
 * 
 * To realize this, subclasses must forward events that are delivered by
 * channels to certain "forward-"methods of the connector. Usually this can be
 * done using a observer pattern and adding a listener to a dynamic data
 * provider that forwards the corresponding events. * Base class for connectors
 * that manage output channels. Output channels are channels with settable
 * values that can be changed by the user during runtime. In comparison to the
 * {@link ReadConnector} the control flow is inverted. In this case a value must
 * be transported FROM the application TO the specific channel architecture.
 * 
 * To realize this, this connector is attached as listener to
 * {@link WidgetProperty} during runtime. If the connector is in connected
 * state, it will forward certain events which are generated by that
 * WidgetProperty to a template method, which has to be implemented by
 * subclasses of this class.
 * 
 * 
 * A connector is a unit that is responsible for connecting a certain channel to
 * a certain connection architecture, e.g. the DAL layer or another dynamic data
 * provider which might also include thread based dummy solutions.
 * 
 * @author Sven Wende
 * 
 */
public abstract class Connector {

	/**
	 * The process variable, that is managed by this connector.
	 */
	private IProcessVariableAddress _processVariable;

	/**
	 * The connection context information.
	 */
	private ConnectionContext _connectionContext;

	/**
	 * A DAL DynamicValueListener instance.
	 */
	private DynamicValueListener _dynamicValueListener;

	/**
	 * A DAL LinkListener instance.
	 */
	private LinkListener _linkListener;

	/**
	 * A DAL ResponseListener instance;
	 */
	private ResponseListener _responseListener;

	/**
	 * A SDS PropertyChangeListener instance.
	 */
	private IPropertyChangeListener _propertyChangeListener;

	/**
	 * Contains the connection service listeners.
	 */
	private List<IConnectorStateListener> _listeners;

	/**
	 * The state of this connector.
	 */
	private ConnectorState _state = new ConnectorState();

	/**
	 * Type of the dynamized widget property.
	 */
	private PropertyTypesEnum _propertyType;

	/**
	 * Flag which can be switched to enable or disable event routing from
	 * control system to UI or vice versa.
	 * 
	 */
	private boolean _routeEvents = true;

	/**
	 * Flag, which indicates, that disconnection is in progress.
	 */
	private boolean _disconnectionInProgress = false;

	/**
	 * The event processor to which new dynamic values will be forwarded. Will
	 * be injected during runtime via a setter method.
	 */
	private ChannelInputProcessor _eventProcessor;

	/**
	 * Constructs a connector for the specified process variable.
	 * 
	 * @param processVariable
	 *            the process variable
	 */
	public Connector(final IProcessVariableAddress processVariable) {
		assert processVariable != null;
		_processVariable = processVariable;
		_listeners = new ArrayList<IConnectorStateListener>();

		// create listeners
		_linkListener = new LinkListenerImpl();
		_dynamicValueListener = new DynamicValueListenerImpl();
		_propertyChangeListener = new ProperyChangeListenerImpl();
		_responseListener = new ResponseListenerImpl();
	}

	/**
	 * Returns the {@link DynamicValueListener}.
	 * 
	 * @return the {@link DynamicValueListener}
	 */
	public final DynamicValueListener getDynamicValueListener() {
		return _dynamicValueListener;
	}

	/**
	 * Returns the {@link IPropertyChangeListener}.
	 * 
	 * @return the {@link IPropertyChangeListener}
	 */
	public final IPropertyChangeListener getPropertyChangeListener() {
		return _propertyChangeListener;
	}

	/**
	 * Returns the {@link LinkListener}.
	 * 
	 * @return the {@link LinkListener}
	 */
	public final LinkListener getLinkListener() {
		return _linkListener;
	}

	public ResponseListener getResponseListener() {
		return _responseListener;
	}

	/**
	 * Sets the event processor to which new dynamic values will be forwarded.
	 * Note: This method is package private, because it should only be called by
	 * the framework.
	 * 
	 * @param processor
	 *            event processor to which new dynamic values will be forwarded
	 */
	final void setProcessor(final ChannelInputProcessor processor) {
		assert processor != null;
		_eventProcessor = processor;
	}

	/**
	 * Adds the specified connection service state listener.
	 * 
	 * @param listener
	 *            the listener
	 */
	public final void addConnectorStateListener(
			final IConnectorStateListener listener) {
		assert listener != null;
		if (!_listeners.contains(listener)) {
			_listeners.add(listener);
		}
	}

	/**
	 * Removes the specified connection service state listener.
	 * 
	 * @param listener
	 *            the listener
	 */
	public final void removeConnectorStateListener(
			final IConnectorStateListener listener) {
		assert listener != null;
		if (_listeners.contains(listener)) {
			_listeners.remove(listener);
		}
	}

	/**
	 * Returns the type of the dynamized widget property.
	 * 
	 * @return the type of the dynamized widget property
	 */
	public final PropertyTypesEnum getPropertyType() {
		return _propertyType;
	}

	/**
	 * Sets the type of the dynamised widget property.
	 * 
	 * @param propertyType
	 *            the widget property´s type
	 */
	public final void setPropertyType(final PropertyTypesEnum propertyType) {
		_propertyType = propertyType;
	}

	/**
	 * Gets the connection context.
	 * 
	 * @return the current connection context
	 */
	public final ConnectionContext getConnectionContext() {
		return _connectionContext;
	}

	/**
	 * Sets the event routing flag. If set to true, all events are forwarded
	 * from the controlsystem to the UI and vice versa (in case the connector is
	 * connected). If set to false, no events are forwarded.
	 * 
	 * @param routeEvents
	 *            the event routing flag, true if events should be forwarded,
	 *            false otherwise
	 */
	public final void setRouteEvents(final boolean routeEvents) {
		_routeEvents = routeEvents;
	}

	/**
	 * Gets the event routing flag.
	 * 
	 * @return true, if all events should be forwarded from the controlsystem to
	 *         the UI and vice versa, false if not events should be forwarded in
	 *         both directions
	 */
	public final boolean isRouteEvents() {
		return _routeEvents;
	}

	/**
	 * Sets the connection context. Note: This method is package private,
	 * because it should only be called by the framework to inject connection
	 * context at runtime.
	 * 
	 * @param connectionContext
	 *            the connection context
	 */
	final void setConnectionContext(final ConnectionContext connectionContext) {
		_connectionContext = connectionContext;
	}

	/**
	 * Gets the process variable pointer this connector is responsible for.
	 * 
	 * @return the process variable pointer
	 */
	public final IProcessVariableAddress getProcessVariable() {
		return _processVariable;
	}

	/**
	 * Gets the connector´s state.
	 * 
	 * @return the connector state
	 */
	public final ConnectorState getState() {
		return _state;
	}

	/**
	 * Connects the connector to the control system.
	 */
	public final void connect() {
		if (!_disconnectionInProgress) {
			doConnect();
		}
	}

	/**
	 * Disconnects the connector from the control system.
	 */
	public final void disconnect() {
		_disconnectionInProgress = true;
		doDisconnect();
		_disconnectionInProgress = false;
	}

	//
	// Abstract template methods.
	//

	/**
	 * This method is called, when the connector is beeing connected. Subclasses
	 * have to implement the necessary linking code in here.
	 * 
	 * The main result of this method call should be, that the different
	 * listeners returned by {@link #getLinkListener()},
	 * {@link #getDynamicValueListener()} and
	 * {@link #getPropertyChangeListener()} are linked to the real connection
	 * layer for which the connector is implemented.
	 */
	protected abstract void doConnect();

	/**
	 * This method is called, when the connector is beeing disconnected.
	 * Subclasses have to implement the necessary unlinking code in here.
	 * 
	 * The main result of this method call should be, that the different
	 * listeners returned by {@link #getLinkListener()},
	 * {@link #getDynamicValueListener()} and
	 * {@link #getPropertyChangeListener()} are unlinked from the real
	 * connection layer for which the connector is implemented.
	 */
	protected abstract void doDisconnect();

	/**
	 * This method is called, when a manual value change is performed on a
	 * widget (e.g. a slider). Subclasses have to forward this new value (which
	 * can be understand as a "target-value-request" to an
	 * Input-Output-Controller (IOC)) to the specific control system
	 * architecture.
	 * 
	 * @param newValue
	 *            the value as requested by an user action
	 */
	protected abstract void doProcessManualValueChange(Object newValue);

	/**
	 * Subclasses should forward condition state changes to this method.
	 * 
	 * @param condition
	 *            the current condition state
	 */
	protected final void forwardConditionStateChange(
			final DynamicValueCondition condition) {
		// TODO: Scheinbar können Condition States auch in Kombination
		// auftreten. Das würde bedeuten, man müßte das komplette EnumSet
		// forwarden.
		if (_eventProcessor != null) {
			if (condition.getStates() != null) {
				for (DynamicValueState state : condition.getStates()) {
					_eventProcessor.conditionStateChanged(state);
				}
			}
		}
	}

	/**
	 * Subclasses should forward new dynamic values to this method.
	 * 
	 * @param newValue
	 *            the new value as delivered by the specific data provider
	 */
	protected final void forwardValueChange(final Object newValue) {
		if (isRouteEvents() && _eventProcessor != null) {
			_eventProcessor.valueChanged(newValue);
		}
	}

	/**
	 * Subclasses should forward connection state changes to this method.
	 * 
	 * @param newState
	 *            the current connection state
	 */
	protected final void forwardConnectionStateChange(
			final ConnectionState newState) {
		ConnectionState oldState = _state.getConnectionState();

		// set the state
		_state.setConnectionState(newState);

		// inform subclasses of the state change
		handleConnectionStateTransition(oldState, newState);

		// inform connector listeners
		fireConnectorStateChange();

		// forward events to the UI
		if (isRouteEvents() && _eventProcessor != null) {
			_eventProcessor.connectionStateChanged(newState);
		}
	}

	/**
	 * This method is called when the connection state changes. Subclasses
	 * mighth react on certain state transitions. E.g. a transition from
	 * {@link ConnectionState#CONNECTION_LOST} to
	 * {@link ConnectionState#CONNECTED} might trigger a value request, to get
	 * the latest value again.
	 * 
	 * @param oldState
	 *            the old connection state
	 * @param newState
	 *            the new connection state
	 */
	protected abstract void handleConnectionStateTransition(
			ConnectionState oldState, ConnectionState newState);

	protected void logError(String message, Exception e) {
		CentralLogger.getInstance().info(
				null,
				"[" + getProcessVariable().getFullName() + "] : ["
						+ Connector.this.hashCode() + "] : " + message);

		e.printStackTrace();
	}

	protected void logInfo(String message) {
		CentralLogger.getInstance().info(
				null,
				"[" + getProcessVariable().getFullName() + "] : ["
						+ Connector.this.hashCode() + "] : " + message);

	}

	/**
	 * Fires events for all connection service state listener.
	 */
	private void fireConnectorStateChange() {
		for (IConnectorStateListener l : _listeners) {
			l.connectorStateChanged(this);
		}
	}

	/**
	 * LinkListener implementation.
	 * 
	 * @author Sven Wende
	 * 
	 */
	class LinkListenerImpl implements LinkListener<DynamicValueProperty> {

		/**
		 * {@inheritDoc}
		 */
		public void connected(final ConnectionEvent<DynamicValueProperty> e) {
			handleConnectionEvent(e);
		}

		/**
		 * {@inheritDoc}
		 */
		public void connectionFailed(
				final ConnectionEvent<DynamicValueProperty> e) {
			handleConnectionEvent(e);
		}

		/**
		 * {@inheritDoc}
		 */
		public void connectionLost(final ConnectionEvent<DynamicValueProperty> e) {
			handleConnectionEvent(e);
		}

		/**
		 * {@inheritDoc}
		 */
		public final void destroyed(
				final ConnectionEvent<DynamicValueProperty> e) {
			handleConnectionEvent(e);
		}

		/**
		 * {@inheritDoc}
		 */
		public final void disconnected(
				final ConnectionEvent<DynamicValueProperty> e) {
			handleConnectionEvent(e);
		}

		/**
		 * {@inheritDoc}
		 */
		public void resumed(final ConnectionEvent<DynamicValueProperty> e) {
			handleConnectionEvent(e);
		}

		/**
		 * {@inheritDoc}
		 */
		public final void suspended(
				final ConnectionEvent<DynamicValueProperty> e) {
			handleConnectionEvent(e);
		}

		/**
		 * Handle the specified connection event.
		 * 
		 * @param event
		 *            the connection event
		 */
		private void handleConnectionEvent(final ConnectionEvent event) {
			ConnectionState newState = event.getState();
			forwardConnectionStateChange(newState);
		}
	}

	/**
	 * DynamicValueListener implementation.
	 * 
	 * @author Sven Wende
	 * 
	 */
	class DynamicValueListenerImpl implements DynamicValueListener {
		/**
		 * {@inheritDoc}
		 */
		public final void conditionChange(final DynamicValueEvent event) {
			handleDynamicValueEvent(event);
		}

		/**
		 * {@inheritDoc}
		 */
		public final void errorResponse(final DynamicValueEvent event) {
			handleDynamicValueEvent(event);
		}

		/**
		 * {@inheritDoc}
		 */
		public final void timelagStarts(final DynamicValueEvent event) {
			handleDynamicValueEvent(event);
		}

		/**
		 * {@inheritDoc}
		 */
		public final void timelagStops(final DynamicValueEvent event) {
			handleDynamicValueEvent(event);
		}

		/**
		 * {@inheritDoc}
		 */
		public final void timeoutStarts(final DynamicValueEvent event) {
			handleDynamicValueEvent(event);
		}

		/**
		 * {@inheritDoc}
		 */
		public final void timeoutStops(final DynamicValueEvent event) {
			handleDynamicValueEvent(event);
		}

		/**
		 * {@inheritDoc}
		 */
		public final void valueChanged(final DynamicValueEvent event) {
			handleValueChange(event);
		}

		/**
		 * {@inheritDoc}
		 */
		public final void valueUpdated(final DynamicValueEvent event) {
			handleValueChange(event);
		}

		/**
		 * Handle the specified dynamic value event.
		 * 
		 * @param event
		 *            the dynamic value event
		 */
		private void handleValueChange(final DynamicValueEvent event) {
			Object value = event.getValue();

			if (value != null) {
				forwardValueChange(value);
			}
			_state.setLatestValue(value);
			_state.setLatestValueTimestamp(event.getTimestamp()
					.getMilliseconds());

			fireConnectorStateChange();
		}

		/**
		 * Handles the specified dynamic value event.
		 * 
		 * @param event
		 *            the dynamic value event
		 */
		private void handleDynamicValueEvent(final DynamicValueEvent event) {
			_state.setDynamicValueCondition(event.getCondition());
			fireConnectorStateChange();

			if (isRouteEvents() && event.getCondition() != null) {
				forwardConditionStateChange(event.getCondition());
			}
		}
	}

	/**
	 * PropertyChangeListener implementation.
	 * 
	 * @author Sven Wende
	 * 
	 */
	class ProperyChangeListenerImpl implements IPropertyChangeListener {
		/**
		 * {@inheritDoc}
		 */
		public final void dynamicsDescriptorChanged(
				final DynamicsDescriptor dynamicsDescriptor) {
			// do nothing
		}

		/**
		 * {@inheritDoc}
		 */
		public final void propertyManualValueChanged(final Object manualValue) {
			// forward manual changes to a template method
			if (isRouteEvents()) {
				doProcessManualValueChange(manualValue);
			}
		}

		/**
		 * {@inheritDoc}
		 */
		public final void propertyValueChanged(final Object oldValue,
				final Object newValue) {
			// do nothing
		}
	}

	class ResponseListenerImpl implements ResponseListener {

		public void responseError(ResponseEvent event) {
			// ignore errors
			// FIXME:
			CentralLogger.getInstance().error(null,
					"ERROR CHARACTERISTIC: " + event.toString());
		}

		public void responseReceived(ResponseEvent event) {
			Object id = event.getResponse().getIdTag();
			Object value = event.getResponse().getValue();

			if (value != null) {
				if (getProcessVariable().isCharacteristic()) {
					// only forward the value, if it´s the right characteristic
					if (id != null
							&& id.equals(getProcessVariable()
									.getCharacteristic())) {
						forwardValueChange(value);
					}
				} else {
					// forward any value change, if the pv does not contain a
					// characteristic
					forwardValueChange(value);
				}
			}
		}
	}

}
